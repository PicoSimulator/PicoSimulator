# 0 "../src/armv6m/core.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "../src/armv6m/core.cpp"



# 1 "./armv6m/opcodes.hpp" 1
       
# 5 "../src/armv6m/core.cpp" 2
# 13 "../src/armv6m/core.cpp"
using namespace ARMv6M;

void ARMv6MCore::tick()
{

  if (m_waiting_for_tick) {
    m_waiting_for_tick = false;
    m_core_task.resume();
  }
  m_tickcnt++;
}

void ARMv6MCore::reset()
{
  m_in_reset = true;
}

void ARMv6MCore::dump() const
{
  for (int i = 0; i < 12; i++) {
    std::cout << "R" << std::setfill(' ') << std::setw(2) << std::left << i << "  " << std::hex << std::setw(8) << std::right << std::setfill(' ') << m_regs[i] << std::dec << std::endl;
  }
  std::cout << "SP   " << std::hex << std::setw(8) << std::right << std::setfill(' ') << SP() << std::dec << std::endl;
  std::cout << "MSP  " << std::hex << std::setw(8) << std::right << std::setfill(' ') << m_MSP << std::dec << std::endl;
  std::cout << "PSP  " << std::hex << std::setw(8) << std::right << std::setfill(' ') << m_PSP << std::dec << std::endl;
  std::cout << "LR   " << std::hex << std::setw(8) << std::right << std::setfill(' ') << LR() << std::dec << std::endl;
  std::cout << "PC   " << std::hex << std::setw(8) << std::right << std::setfill(' ') << PC() << std::dec << std::endl;

  std::cout << "APSR " << std::bitset<32>{m_APSR} << std::endl;
  std::cout << "     NZCV" << std::endl;
}

BusMaster ARMv6MCore::core_task()
{
  while(true){

    for (int i = 0; i < 12; i++) {
      m_regs[i] = 0;
    }
    uint32_t vectortable = 0;
    m_threadMode = true;

    m_regs[15] = 1;
    m_regs[14] = 0;
    m_regs[13] = 0;
    m_MSP = 0;
    m_PSP = 0;
    m_APSR = 0;
    m_IPSR = 0;
    m_EPSR = 0;
    m_PRIMASK = 0;
    m_CONTROL = 0;
    m_MSP = co_await m_mpu_bus_interface.read_word(vectortable + 0x00);
    SP() = m_MSP;
    uint32_t start = co_await m_mpu_bus_interface.read_word(vectortable + 0x04);
    PC() = start;

    std::cout << std::hex << std::setw(8) << std::setfill('0') << SP() << std::dec << std::endl;
    std::cout << std::hex << std::setw(8) << std::setfill('0') << PC() << std::dec << std::endl;
    m_in_reset = false;
    while (!m_in_reset) {

      uint8_t instr_incr = 2;
      try{

        uint32_t instr;
        if (!T())
        {

          throw HardFault{"ARM mode not supported!"};
          instr = co_await m_mpu_bus_interface.read_word(instr_addr());
          instr_incr = 4;
        }
        else
        {

          instr = co_await m_mpu_bus_interface.read_halfword(instr_addr()) << 16;
          if ((instr & 0xf800'0000) >= 0xe100'0000) {

            co_await next_tick();
            instr = instr | co_await m_mpu_bus_interface.read_halfword(instr_addr() + 2);
            instr_incr = 4;
          }
        }
        m_nextPC = PC() + instr_incr;
        std::cout << "fetch complete " << m_name << " instr: "
          << std::hex << std::setw(8) << std::setfill('0') << instr << std::dec
          << " addr: "
          << std::hex << std::setw(8) << std::setfill('0') << PC() << std::dec
          << std::endl;

        co_await exec_instr(instr);
        PC() = m_nextPC;







      } catch (ARMv6M::HardFault fault) {
        std::cout << "Hardfault on instruction fetch" << std::endl;
        dump();


        std::terminate();


        R"____(
            // ExceptionEntry()
            // =================
            ExceptionEntry(integer ExceptionType)
            // NOTE: PushStack() can abandon memory accesses if a fault occurs during the stacking
            // sequence.
            // Exception entry is modified according to the behavior of a derived exception.
            PushStack(ExceptionType);
            ExceptionTaken(ExceptionType); // ExceptionType is encoded as its exception number
            // PushStack()
            // ===========
            PushStack(integer ExceptionType)
              if CONTROL.SPSEL == ‘1’ && CurrentMode == Mode_Thread then
                frameptralign = SP_process<2>;
                SP_process = (SP_process - 0x20) AND NOT(ZeroExtend(‘100’,32));
                frameptr = SP_process;
              else
                frameptralign = SP_main<2>;
                SP_main = (SP_main - 0x20) AND NOT(ZeroExtend(‘100’,32));
                frameptr = SP_main;
              /* only the stack locations, not the store order, are architected */
              MemA[frameptr,4] = R[0];
              MemA[frameptr+0x4,4] = R[1];
              MemA[frameptr+0x8,4] = R[2];
              MemA[frameptr+0xC,4] = R[3];
              MemA[frameptr+0x10,4] = R[12];
              MemA[frameptr+0x14,4] = LR;
              MemA[frameptr+0x18,4] = ReturnAddress(ExceptionType);
              MemA[frameptr+0x1C,4] = (XPSR<31:10>:frameptralign:XPSR<8:0>);
              if CurrentMode==Mode_Handler then
                LR = 0xFFFFFFF1<31:0>;
              else
                if CONTROL.SPSEL == ‘0’ then
                  LR = 0xFFFFFFF9<31:0>;
                else
                  LR = 0xFFFFFFFD<31:0>;
              return;

            // ExceptionTaken()
            // ================
            ExceptionTaken(integer ExceptionNumber)
              for n = 0 to 3
              R[n] = bits(32) UNKNOWN; // Original values pushed on stack
              R[12] = bits(32) UNKNOWN;
              APSR = bits(32) UNKNOWN;
              CurrentMode = Mode_Handler; // Enter Handler Mode, now Privileged
              IPSR<5:0> = ExceptionNumber<5:0>; // Update IPSR to this exception
              CONTROL.SPSEL = ‘0’; // Current stack is now SP main
              // CONTROL.nPRIV unchanged
              ExceptionActive[ExceptionNumber] = ‘1’; // Set exception as being active
              SCS_UpdateStatusRegs(); // Update SCS registers
              SetEventRegister(); // See WFE instruction for details
              InstructionSynchronizationBarrier(‘1111’);
              bits(32) vectortable = VTOR;
              start = MemA[vectortable+4*ExceptionNumber,4]; // Load handler address
              BLXWritePC(start); // Start execution of handler

              // ReturnAddress()
              // ===============
              bits(32) ReturnAddress(integer ExceptionType)
              // Returns the following values based on the exception cause
              // NOTE: ReturnAddress() is always halfword aligned, meaning bit<0> is always zero
                if ExceptionType == NMI then result = NextInstrAddr();
                elsif ExceptionType == HardFault then
                  result = if IsExceptionSynchronous() then ThisInstrAddr() else NextInstrAddr();
                elsif ExceptionType == SVCall then result = NextInstrAddr();
                elsif ExceptionType == PendSV then result = NextInstrAddr();
                elsif ExceptionType == SysTick then result = NextInstrAddr();
                elsif ExceptionType >= 16 then // External interrupt
                  result = NextInstrAddr();
                else
                  assert(FALSE); // Unknown exception number
                return result;
        )____";
        uint32_t sp, frameptr;
        if (m_CONTROL & CONTROL::SPSEL && m_threadMode) {
          sp = m_PSP;
          m_PSP -= 0x20;
          m_PSP &= ~0x100;
          frameptr = m_PSP;
        } else {
          sp = m_MSP;
          m_MSP -= 0x20;
          m_MSP &= ~0x100;
          frameptr = m_MSP;
        }
        m_bus_interface.write_word(frameptr, m_regs[0]);
        m_bus_interface.write_word(frameptr + 0x4, m_regs[1]);
        m_bus_interface.write_word(frameptr + 0x8, m_regs[2]);
        m_bus_interface.write_word(frameptr + 0xC, m_regs[3]);
        m_bus_interface.write_word(frameptr + 0x10, m_regs[12]);
        m_bus_interface.write_word(frameptr + 0x14, LR());
        m_bus_interface.write_word(frameptr + 0x18, ReturnAddress(ExceptionType::HardFault));
        m_bus_interface.write_word(frameptr + 0x1C, (XPSR() & 0xFFFFFC00) | ((sp & 0x2) << 8) | (XPSR() & 0x1FF));
        if (m_threadMode) {
          LR() = 0xFFFFFFF1;
        } else {
          if (!(m_CONTROL & CONTROL::SPSEL)) {
            LR() = 0xFFFFFFF9;
          } else {
            LR() = 0xFFFFFFFD;
          }
        }

      }
      co_await next_tick();
    }
  }
}

Awaitable<void> ARMv6MCore::exec_instr(uint32_t instr)
{
# 255 "../src/armv6m/core.cpp"
  switch(instr >> 25) {
    case 0b0000'000: { uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t imm5 = (instr >> 22) & 0x1f; ({ std::cout << std::hex << std::setw(4) << std::setfill('0') << ((instr >> 16) & 0xffff) << "     " << std::dec << ("LSL") << " R" << (Rd) << ", R" << (Rm) << ", #" << (imm5) << std::endl; }); ({ uint32_t Rm_val = this->get_reg(Rm); bool carry_out = Rm_val & (1<<(32-imm5)); if (imm5 != 0) { Rm_val <<= imm5; } this->set_reg(Rd, Rm_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (Rm_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rm_val == 0) { m_APSR |= APSR::ZERO; } if (carry_out) { m_APSR |= APSR::CARRY; }}); std::cout << "T:" << "R" << Rd << "=0x" << std::hex << Rm_val << << ";FLAGS=" << std::bitstream<4>{this->m_APSR>>28} << std::endl; }); }; break; case 0b0000'001: { uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t imm5 = (instr >> 22) & 0x1f; ({ std::cout << std::hex << std::setw(4) << std::setfill('0') << ((instr >> 16) & 0xffff) << "     " << std::dec << ("LSL") << " R" << (Rd) << ", R" << (Rm) << ", #" << (imm5) << std::endl; }); ({ uint32_t Rm_val = this->get_reg(Rm); bool carry_out = Rm_val & (1<<(32-imm5)); if (imm5 != 0) { Rm_val <<= imm5; } this->set_reg(Rd, Rm_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (Rm_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rm_val == 0) { m_APSR |= APSR::ZERO; } if (carry_out) { m_APSR |= APSR::CARRY; }}); std::cout << "T:" << "R" << Rd << "=0x" << std::hex << Rm_val << << ";FLAGS=" << std::bitstream<4>{this->m_APSR>>28} << std::endl; }); }; break; case 0b0000'010: { uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t imm5 = (instr >> 22) & 0x1f; ({ std::cout << std::hex << std::setw(4) << std::setfill('0') << ((instr >> 16) & 0xffff) << "     " << std::dec << ("LSL") << " R" << (Rd) << ", R" << (Rm) << ", #" << (imm5) << std::endl; }); ({ uint32_t Rm_val = this->get_reg(Rm); bool carry_out = Rm_val & (1<<(32-imm5)); if (imm5 != 0) { Rm_val <<= imm5; } this->set_reg(Rd, Rm_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (Rm_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rm_val == 0) { m_APSR |= APSR::ZERO; } if (carry_out) { m_APSR |= APSR::CARRY; }}); std::cout << "T:" << "R" << Rd << "=0x" << std::hex << Rm_val << << ";FLAGS=" << std::bitstream<4>{this->m_APSR>>28} << std::endl; }); }; break; case 0b0000'011: { uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t imm5 = (instr >> 22) & 0x1f; ({ std::cout << std::hex << std::setw(4) << std::setfill('0') << ((instr >> 16) & 0xffff) << "     " << std::dec << ("LSL") << " R" << (Rd) << ", R" << (Rm) << ", #" << (imm5) << std::endl; }); ({ uint32_t Rm_val = this->get_reg(Rm); bool carry_out = Rm_val & (1<<(32-imm5)); if (imm5 != 0) { Rm_val <<= imm5; } this->set_reg(Rd, Rm_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (Rm_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rm_val == 0) { m_APSR |= APSR::ZERO; } if (carry_out) { m_APSR |= APSR::CARRY; }}); std::cout << "T:" << "R" << Rd << "=0x" << std::hex << Rm_val << << ";FLAGS=" << std::bitstream<4>{this->m_APSR>>28} << std::endl; }); }; break; case 0b0000'100: { uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t imm5 = (instr >> 22) & 0x1f; ({ std::cout << std::hex << std::setw(4) << std::setfill('0') << ((instr >> 16) & 0xffff) << "     " << std::dec << ("LSR") << " R" << (Rd) << ", R" << (Rm) << ", #" << (imm5) << std::endl; }); ({ uint32_t Rm_val = this->get_reg(Rm); bool carry_out = Rm_val & (1<<(32-imm5)); if (imm5 != 0) { Rm_val >>= imm5; } this->set_reg(Rd, Rm_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (Rm_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rm_val == 0) { m_APSR |= APSR::ZERO; } if (carry_out) { m_APSR |= APSR::CARRY; }}); std::cout << "T:" << "R" << Rd << "=0x" << std::hex << Rm_val << << ";FLAGS=" << std::bitstream<4>{this->m_APSR>>28} << std::endl; }); }; break; case 0b0000'101: { uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t imm5 = (instr >> 22) & 0x1f; ({ std::cout << std::hex << std::setw(4) << std::setfill('0') << ((instr >> 16) & 0xffff) << "     " << std::dec << ("LSR") << " R" << (Rd) << ", R" << (Rm) << ", #" << (imm5) << std::endl; }); ({ uint32_t Rm_val = this->get_reg(Rm); bool carry_out = Rm_val & (1<<(32-imm5)); if (imm5 != 0) { Rm_val >>= imm5; } this->set_reg(Rd, Rm_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (Rm_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rm_val == 0) { m_APSR |= APSR::ZERO; } if (carry_out) { m_APSR |= APSR::CARRY; }}); std::cout << "T:" << "R" << Rd << "=0x" << std::hex << Rm_val << << ";FLAGS=" << std::bitstream<4>{this->m_APSR>>28} << std::endl; }); }; break; case 0b0000'110: { uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t imm5 = (instr >> 22) & 0x1f; ({ std::cout << std::hex << std::setw(4) << std::setfill('0') << ((instr >> 16) & 0xffff) << "     " << std::dec << ("LSR") << " R" << (Rd) << ", R" << (Rm) << ", #" << (imm5) << std::endl; }); ({ uint32_t Rm_val = this->get_reg(Rm); bool carry_out = Rm_val & (1<<(32-imm5)); if (imm5 != 0) { Rm_val >>= imm5; } this->set_reg(Rd, Rm_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (Rm_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rm_val == 0) { m_APSR |= APSR::ZERO; } if (carry_out) { m_APSR |= APSR::CARRY; }}); std::cout << "T:" << "R" << Rd << "=0x" << std::hex << Rm_val << << ";FLAGS=" << std::bitstream<4>{this->m_APSR>>28} << std::endl; }); }; break; case 0b0000'111: { uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t imm5 = (instr >> 22) & 0x1f; ({ std::cout << std::hex << std::setw(4) << std::setfill('0') << ((instr >> 16) & 0xffff) << "     " << std::dec << ("LSR") << " R" << (Rd) << ", R" << (Rm) << ", #" << (imm5) << std::endl; }); ({ uint32_t Rm_val = this->get_reg(Rm); bool carry_out = Rm_val & (1<<(32-imm5)); if (imm5 != 0) { Rm_val >>= imm5; } this->set_reg(Rd, Rm_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (Rm_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rm_val == 0) { m_APSR |= APSR::ZERO; } if (carry_out) { m_APSR |= APSR::CARRY; }}); std::cout << "T:" << "R" << Rd << "=0x" << std::hex << Rm_val << << ";FLAGS=" << std::bitstream<4>{this->m_APSR>>28} << std::endl; }); }; break; case 0b0001'000: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b0001'001: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b0001'010: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b0001'011: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b0001'100: { uint32_t Rd = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rm = (instr >> 22) & 0x7; ({ std::cout << std::hex << std::setw(4) << std::setfill('0') << ((instr >> 16) & 0xffff) << "     " << std::dec << ("ADD") << " R" << (Rd) << ", R" << (Rn) << ", R" << (Rm) << std::endl; }); ({ uint32_t Rn_val = this->get_reg(Rn); uint32_t Rm_val = this->get_reg(Rm); auto _res = AddWithCarry(Rn_val, Rm_val, 0); auto result = std::get<0>(_res); auto carry = std::get<1>(_res); auto overflow = std::get<2>(_res); ; }); }; break; case 0b0001'101: { uint32_t Rd = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rm = (instr >> 22) & 0x7; }; break; case 0b0001'110: { uint32_t Rd = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t imm3 = (instr >> 22) & 0x7; }; break; case 0b0001'111: { uint32_t Rd = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t imm3 = (instr >> 22) & 0x7; }; break; case 0b0010'000: { uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rd = (instr >> 24) & 0x07; }; break; case 0b0010'001: { uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rd = (instr >> 24) & 0x07; }; break; case 0b0010'010: { uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rd = (instr >> 24) & 0x07; }; break; case 0b0010'011: { uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rd = (instr >> 24) & 0x07; }; break; case 0b0010'100: { uint32_t imm8 = (instr >> 16) & 0xff; uint32_t simm32 = ~imm8; uint32_t Rn = (instr >> 24) & 0x07; uint32_t Rn_val = get_reg(Rn); std::cout << "CMP R" << Rn << ", #" << imm8 << std::endl; auto [result, carry, overflow] = AddWithCarry(Rn_val, simm32, 1); std::cout << carry << std::endl; m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0010'101: { uint32_t imm8 = (instr >> 16) & 0xff; uint32_t simm32 = ~imm8; uint32_t Rn = (instr >> 24) & 0x07; uint32_t Rn_val = get_reg(Rn); std::cout << "CMP R" << Rn << ", #" << imm8 << std::endl; auto [result, carry, overflow] = AddWithCarry(Rn_val, simm32, 1); std::cout << carry << std::endl; m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0010'110: { uint32_t imm8 = (instr >> 16) & 0xff; uint32_t simm32 = ~imm8; uint32_t Rn = (instr >> 24) & 0x07; uint32_t Rn_val = get_reg(Rn); std::cout << "CMP R" << Rn << ", #" << imm8 << std::endl; auto [result, carry, overflow] = AddWithCarry(Rn_val, simm32, 1); std::cout << carry << std::endl; m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0010'111: { uint32_t imm8 = (instr >> 16) & 0xff; uint32_t simm32 = ~imm8; uint32_t Rn = (instr >> 24) & 0x07; uint32_t Rn_val = get_reg(Rn); std::cout << "CMP R" << Rn << ", #" << imm8 << std::endl; auto [result, carry, overflow] = AddWithCarry(Rn_val, simm32, 1); std::cout << carry << std::endl; m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0011'000: { uint32_t Rdn = (instr >> 24) & 0x7; uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rn_val = get_reg(Rdn); std::cout << "ADD R" << Rdn << ", R" << Rdn << ", #" << imm8 << std::endl; auto [result, carry, overflow] = AddWithCarry(Rn_val, imm8, 0); set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0011'001: { uint32_t Rdn = (instr >> 24) & 0x7; uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rn_val = get_reg(Rdn); std::cout << "ADD R" << Rdn << ", R" << Rdn << ", #" << imm8 << std::endl; auto [result, carry, overflow] = AddWithCarry(Rn_val, imm8, 0); set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0011'010: { uint32_t Rdn = (instr >> 24) & 0x7; uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rn_val = get_reg(Rdn); std::cout << "ADD R" << Rdn << ", R" << Rdn << ", #" << imm8 << std::endl; auto [result, carry, overflow] = AddWithCarry(Rn_val, imm8, 0); set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0011'011: { uint32_t Rdn = (instr >> 24) & 0x7; uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rn_val = get_reg(Rdn); std::cout << "ADD R" << Rdn << ", R" << Rdn << ", #" << imm8 << std::endl; auto [result, carry, overflow] = AddWithCarry(Rn_val, imm8, 0); set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0011'100: { uint32_t Rdn = (instr >> 24) & 0x7; uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rn_val = get_reg(Rdn); auto [result, carry, overflow] = AddWithCarry(Rn_val, ~imm8, 1); std::cout << "SUB R" << Rdn << ", R" << Rdn << ", #" << imm8 << " ; R" << Rdn << " = " << result << std::endl; set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0011'101: { uint32_t Rdn = (instr >> 24) & 0x7; uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rn_val = get_reg(Rdn); auto [result, carry, overflow] = AddWithCarry(Rn_val, ~imm8, 1); std::cout << "SUB R" << Rdn << ", R" << Rdn << ", #" << imm8 << " ; R" << Rdn << " = " << result << std::endl; set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0011'110: { uint32_t Rdn = (instr >> 24) & 0x7; uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rn_val = get_reg(Rdn); auto [result, carry, overflow] = AddWithCarry(Rn_val, ~imm8, 1); std::cout << "SUB R" << Rdn << ", R" << Rdn << ", #" << imm8 << " ; R" << Rdn << " = " << result << std::endl; set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0011'111: { uint32_t Rdn = (instr >> 24) & 0x7; uint32_t imm8 = (instr >> 16) & 0xff; uint32_t Rn_val = get_reg(Rdn); auto [result, carry, overflow] = AddWithCarry(Rn_val, ~imm8, 1); std::cout << "SUB R" << Rdn << ", R" << Rdn << ", #" << imm8 << " ; R" << Rdn << " = " << result << std::endl; set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); }; break; case 0b0100'000: { uint8_t sub_opcode = (instr >> 22) & 0xf; switch(sub_opcode) { case 0b0000:{ uint32_t Rdn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); Rdn_val &= Rm_val; std::cout << "AND R"<< Rdn << ", R" << Rm << " ; R" << Rm << " = " << Rdn_val << std::endl; set_reg(Rdn, Rdn_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (Rdn_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rdn_val == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b0001:{ uint32_t Rdn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); Rdn_val ^= Rm_val; std::cout << "EOR R"<< Rdn << ", R" << Rm << " ; R" << Rm << " = " << Rdn_val << std::endl; set_reg(Rdn, Rdn_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (Rdn_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rdn_val == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b0101:{ uint32_t Rdn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); bool cin = m_APSR & APSR::CARRY; auto [result, cout, v] = AddWithCarry(Rdn_val, Rm_val, cin); std::cout << "ADC R"<< Rdn << ", R" << Rm << " ; R" << Rm << " = " << result << std::endl; set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (cout) { m_APSR |= APSR::CARRY; } if (v) { m_APSR |= APSR::OVERFLOW; }}); } break; case 0b0110:{ uint32_t Rdn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); bool cin = m_APSR & APSR::CARRY; auto [result, cout, v] = AddWithCarry(Rdn_val, ~Rm_val, cin); std::cout << "SBC R"<< Rdn << ", R" << Rm << " ; R" << Rm << " = " << result << std::endl; set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (cout) { m_APSR |= APSR::CARRY; } if (v) { m_APSR |= APSR::OVERFLOW; }}); } break; case 0b1000:{ uint32_t Rn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rn_val = get_reg(Rn); uint32_t Rm_val = get_reg(Rm); uint32_t result = Rn_val & Rm_val; std::cout << "TST R"<< Rn << ", R" << Rm << std::endl; ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b1001:{ uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rn = (instr >> 19) & 0x07; uint32_t Rn_val = get_reg(Rn); auto [result, carry, overflow] = AddWithCarry(~Rn_val, 0, 1); std::cout << "RSB R"<< Rd << ", R" << Rn << std::endl; set_reg(Rd, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); } break; case 0b1010:{ uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rn = (instr >> 16) & 0x07; uint32_t Rm_val = get_reg(Rm); uint32_t Rn_val = get_reg(Rn); auto [result, carry, overflow] = AddWithCarry(Rn_val, ~Rm_val, true); std::cout << "CMP R"<< Rm << ", R" << Rn << std::endl; ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); } break; case 0b1100:{ uint32_t Rdn = (instr >> 16) & 0x7; uint32_t Rm = (instr >> 19) & 0x7; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); Rdn_val |= Rm_val; std::cout << "ORR R" << Rdn << ", R" << Rm << std::endl; set_reg(Rdn, Rdn_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (Rdn_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rdn_val == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b1110:{ uint32_t Rd = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rd_val = get_reg(Rd); uint32_t Rn_val = get_reg(Rn); Rd_val &= ~Rn_val; std::cout << "BIC R" << Rd << ", R" << Rn << std::endl; set_reg(Rd, Rd_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (Rd_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rd_val == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b1111:{ uint32_t Rd = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; std::cout << "MVN R" << Rd << ", R" << Rn << std::endl; set_reg(Rd, ~get_reg(Rn)); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (~get_reg(Rn) & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (~get_reg(Rn) == 0) { m_APSR |= APSR::ZERO; } if (false) { m_APSR |= APSR::CARRY; }}); } break; default: throw HardFault{"Unknown arith instr"}; }}; break; case 0b0100'001: { uint8_t sub_opcode = (instr >> 22) & 0xf; switch(sub_opcode) { case 0b0000:{ uint32_t Rdn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); Rdn_val &= Rm_val; std::cout << "AND R"<< Rdn << ", R" << Rm << " ; R" << Rm << " = " << Rdn_val << std::endl; set_reg(Rdn, Rdn_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (Rdn_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rdn_val == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b0001:{ uint32_t Rdn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); Rdn_val ^= Rm_val; std::cout << "EOR R"<< Rdn << ", R" << Rm << " ; R" << Rm << " = " << Rdn_val << std::endl; set_reg(Rdn, Rdn_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (Rdn_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rdn_val == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b0101:{ uint32_t Rdn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); bool cin = m_APSR & APSR::CARRY; auto [result, cout, v] = AddWithCarry(Rdn_val, Rm_val, cin); std::cout << "ADC R"<< Rdn << ", R" << Rm << " ; R" << Rm << " = " << result << std::endl; set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (cout) { m_APSR |= APSR::CARRY; } if (v) { m_APSR |= APSR::OVERFLOW; }}); } break; case 0b0110:{ uint32_t Rdn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); bool cin = m_APSR & APSR::CARRY; auto [result, cout, v] = AddWithCarry(Rdn_val, ~Rm_val, cin); std::cout << "SBC R"<< Rdn << ", R" << Rm << " ; R" << Rm << " = " << result << std::endl; set_reg(Rdn, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (cout) { m_APSR |= APSR::CARRY; } if (v) { m_APSR |= APSR::OVERFLOW; }}); } break; case 0b1000:{ uint32_t Rn = (instr >> 16) & 0x07; uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rn_val = get_reg(Rn); uint32_t Rm_val = get_reg(Rm); uint32_t result = Rn_val & Rm_val; std::cout << "TST R"<< Rn << ", R" << Rm << std::endl; ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b1001:{ uint32_t Rd = (instr >> 16) & 0x07; uint32_t Rn = (instr >> 19) & 0x07; uint32_t Rn_val = get_reg(Rn); auto [result, carry, overflow] = AddWithCarry(~Rn_val, 0, 1); std::cout << "RSB R"<< Rd << ", R" << Rn << std::endl; set_reg(Rd, result); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); } break; case 0b1010:{ uint32_t Rm = (instr >> 19) & 0x07; uint32_t Rn = (instr >> 16) & 0x07; uint32_t Rm_val = get_reg(Rm); uint32_t Rn_val = get_reg(Rn); auto [result, carry, overflow] = AddWithCarry(Rn_val, ~Rm_val, true); std::cout << "CMP R"<< Rm << ", R" << Rn << std::endl; ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); } break; case 0b1100:{ uint32_t Rdn = (instr >> 16) & 0x7; uint32_t Rm = (instr >> 19) & 0x7; uint32_t Rdn_val = get_reg(Rdn); uint32_t Rm_val = get_reg(Rm); Rdn_val |= Rm_val; std::cout << "ORR R" << Rdn << ", R" << Rm << std::endl; set_reg(Rdn, Rdn_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (Rdn_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rdn_val == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b1110:{ uint32_t Rd = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rd_val = get_reg(Rd); uint32_t Rn_val = get_reg(Rn); Rd_val &= ~Rn_val; std::cout << "BIC R" << Rd << ", R" << Rn << std::endl; set_reg(Rd, Rd_val); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (Rd_val & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (Rd_val == 0) { m_APSR |= APSR::ZERO; }}); } break; case 0b1111:{ uint32_t Rd = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; std::cout << "MVN R" << Rd << ", R" << Rn << std::endl; set_reg(Rd, ~get_reg(Rn)); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY); if (~get_reg(Rn) & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (~get_reg(Rn) == 0) { m_APSR |= APSR::ZERO; } if (false) { m_APSR |= APSR::CARRY; }}); } break; default: throw HardFault{"Unknown arith instr"}; }}; break; case 0b0100'010: { switch(instr & 0x03c0'0000) { case 0x0140'0000: { uint32_t Rm = (instr >> 19) & 0xf; uint32_t Rn = (instr >> 16) & 0x7 | (instr >> 19) & 0x8; uint32_t Rm_val = get_reg(Rm); uint32_t Rn_val = get_reg(Rn); auto [result, carry, overflow] = AddWithCarry(Rn_val, ~Rm_val, true); std::cout << "CMP R"<< Rm << ", R" << Rn << std::endl; ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO | APSR::CARRY | APSR::OVERFLOW); if (result & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (result == 0) { m_APSR |= APSR::ZERO; } if (carry) { m_APSR |= APSR::CARRY; } if (overflow) { m_APSR |= APSR::OVERFLOW; }}); } break; default: throw HardFault{}; }}; break; case 0b0100'011: { if ((instr & 1<<24) == 0){ uint32_t Rd = ((instr >> 16) & 0x7) | ((instr >> 20) & 0x08) ; uint32_t Rm = (instr >> 19) & 0xf; uint32_t RegVal = get_reg(Rm); std::cout << "MOV R" << Rd << ", R" << Rm << " ; R" << Rd << " = " << RegVal << std::endl; if (Rd == 15) { m_nextPC = RegVal; } else { set_reg(Rd, RegVal); ({m_APSR &= ~(APSR::NEGATIVE | APSR::ZERO); if (RegVal & 0x80000000) { m_APSR |= APSR::NEGATIVE; } if (RegVal == 0) { m_APSR |= APSR::ZERO; }}); } } else if ((instr & 1<<23) == 0) { uint8_t Rm = (instr>>19) & 0xf; BXWritePC(get_reg(Rm)); } else { uint32_t Rm = (instr>>19) & 0xf; LR() = m_nextPC; BLXWritePC(get_reg(Rm)); } }; break; case 0b0100'100: { uint32_t imm8 = (instr >> 16) & 0xFF; uint32_t Rt = (instr >> 24) & 0x7; uint32_t addr = (PC() & ~3) + imm8*4 + 4; std::cout << "LDR R" << Rt << ", [PC, #" << imm8*4 << "] (" << std::hex << addr << std::dec <<")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b0100'101: { uint32_t imm8 = (instr >> 16) & 0xFF; uint32_t Rt = (instr >> 24) & 0x7; uint32_t addr = (PC() & ~3) + imm8*4 + 4; std::cout << "LDR R" << Rt << ", [PC, #" << imm8*4 << "] (" << std::hex << addr << std::dec <<")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b0100'110: { uint32_t imm8 = (instr >> 16) & 0xFF; uint32_t Rt = (instr >> 24) & 0x7; uint32_t addr = (PC() & ~3) + imm8*4 + 4; std::cout << "LDR R" << Rt << ", [PC, #" << imm8*4 << "] (" << std::hex << addr << std::dec <<")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b0100'111: { uint32_t imm8 = (instr >> 16) & 0xFF; uint32_t Rt = (instr >> 24) & 0x7; uint32_t addr = (PC() & ~3) + imm8*4 + 4; std::cout << "LDR R" << Rt << ", [PC, #" << imm8*4 << "] (" << std::hex << addr << std::dec <<")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b0101'000: { uint32_t Rm = (instr >> 22) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rt = (instr >> 16) & 0x7; uint32_t addr = get_reg(Rn) + get_reg(Rm); uint32_t data = get_reg(Rt); co_await m_mpu_bus_interface.write_word(addr, data); }; break; case 0b0101'001: { uint32_t Rm = (instr >> 22) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rt = (instr >> 16) & 0x7; uint32_t addr = get_reg(Rn) + get_reg(Rm); uint32_t data = get_reg(Rt); co_await m_mpu_bus_interface.write_halfword(addr, data); }; break; case 0b0101'010: { uint32_t Rm = (instr >> 22) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rt = (instr >> 16) & 0x7; uint32_t addr = get_reg(Rn) + get_reg(Rm); uint32_t data = get_reg(Rt); co_await m_mpu_bus_interface.write_byte(addr, data); }; break; case 0b0101'011: { uint32_t Rm = (instr >> 22) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rt = (instr >> 16) & 0x7; uint32_t addr = get_reg(Rn) + get_reg(Rm); uint32_t data = co_await m_mpu_bus_interface.read_byte(addr); data = SignExtend(data, 8); std::cout << "LDRSB R" << Rt << ", [R" << Rm << ", R" << Rn << "]" << std::endl; set_reg(Rt, data); }; break; case 0b0101'100: { uint32_t Rm = (instr >> 22) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rt = (instr >> 16) & 0x7; uint32_t addr = get_reg(Rn) + get_reg(Rm); uint32_t data = co_await m_mpu_bus_interface.read_word(addr); std::cout << "LDR R" << Rt << ", [R" << Rm << ", R" << Rn << "]" << std::endl; set_reg(Rt, data); }; break; case 0b0101'101: { uint32_t Rm = (instr >> 22) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rt = (instr >> 16) & 0x7; uint32_t addr = get_reg(Rn) + get_reg(Rm); uint32_t data = co_await m_mpu_bus_interface.read_halfword(addr); std::cout << "LDRH R" << Rt << ", [R" << Rm << ", R" << Rn << "]" << std::endl; set_reg(Rt, data); }; break; case 0b0101'110: { uint32_t Rm = (instr >> 22) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t Rt = (instr >> 16) & 0x7; uint32_t addr = get_reg(Rn) + get_reg(Rm); uint32_t data = co_await m_mpu_bus_interface.read_byte(addr); std::cout << "LDRB R" << Rt << ", [R" << Rm << ", R" << Rn << "]" << std::endl; set_reg(Rt, data); }; break; case 0b0101'111: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b0110'000: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5*4; uint32_t data = get_reg(Rt); std::cout << "STR R" << Rt << ", [R" << Rn << ", #" << imm5*4 << "] (" << std::hex << addr << std::dec << ")" << std::endl; std::cout << &m_mpu_bus_interface << std::endl; co_await m_mpu_bus_interface.write_word(addr, data); }; break; case 0b0110'001: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5*4; uint32_t data = get_reg(Rt); std::cout << "STR R" << Rt << ", [R" << Rn << ", #" << imm5*4 << "] (" << std::hex << addr << std::dec << ")" << std::endl; std::cout << &m_mpu_bus_interface << std::endl; co_await m_mpu_bus_interface.write_word(addr, data); }; break; case 0b0110'010: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5*4; uint32_t data = get_reg(Rt); std::cout << "STR R" << Rt << ", [R" << Rn << ", #" << imm5*4 << "] (" << std::hex << addr << std::dec << ")" << std::endl; std::cout << &m_mpu_bus_interface << std::endl; co_await m_mpu_bus_interface.write_word(addr, data); }; break; case 0b0110'011: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5*4; uint32_t data = get_reg(Rt); std::cout << "STR R" << Rt << ", [R" << Rn << ", #" << imm5*4 << "] (" << std::hex << addr << std::dec << ")" << std::endl; std::cout << &m_mpu_bus_interface << std::endl; co_await m_mpu_bus_interface.write_word(addr, data); }; break; case 0b0110'100: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5*4; std::cout << "LDR R" << Rt << ", [R" << Rn << ", #" << imm5*4 << "] (" << std::hex << addr << std::dec << ")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b0110'101: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5*4; std::cout << "LDR R" << Rt << ", [R" << Rn << ", #" << imm5*4 << "] (" << std::hex << addr << std::dec << ")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b0110'110: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5*4; std::cout << "LDR R" << Rt << ", [R" << Rn << ", #" << imm5*4 << "] (" << std::hex << addr << std::dec << ")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b0110'111: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5*4; std::cout << "LDR R" << Rt << ", [R" << Rn << ", #" << imm5*4 << "] (" << std::hex << addr << std::dec << ")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b0111'000: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5; uint32_t data = get_reg(Rt); std::cout << "STRB R" << Rt << ", [R" << Rn << ", #" << imm5 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_byte(addr, data); }; break; case 0b0111'001: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5; uint32_t data = get_reg(Rt); std::cout << "STRB R" << Rt << ", [R" << Rn << ", #" << imm5 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_byte(addr, data); }; break; case 0b0111'010: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5; uint32_t data = get_reg(Rt); std::cout << "STRB R" << Rt << ", [R" << Rn << ", #" << imm5 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_byte(addr, data); }; break; case 0b0111'011: { uint32_t imm5 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm5; uint32_t data = get_reg(Rt); std::cout << "STRB R" << Rt << ", [R" << Rn << ", #" << imm5 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_byte(addr, data); }; break; case 0b0111'100: { uint32_t imm32 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = co_await m_mpu_bus_interface.read_byte(addr); std::cout << "LDRB R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << "," << data << std::dec << ")" << std::endl; set_reg(Rt, data); }; break; case 0b0111'101: { uint32_t imm32 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = co_await m_mpu_bus_interface.read_byte(addr); std::cout << "LDRB R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << "," << data << std::dec << ")" << std::endl; set_reg(Rt, data); }; break; case 0b0111'110: { uint32_t imm32 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = co_await m_mpu_bus_interface.read_byte(addr); std::cout << "LDRB R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << "," << data << std::dec << ")" << std::endl; set_reg(Rt, data); }; break; case 0b0111'111: { uint32_t imm32 = (instr >> 22) & 0x1F; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = co_await m_mpu_bus_interface.read_byte(addr); std::cout << "LDRB R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << "," << data << std::dec << ")" << std::endl; set_reg(Rt, data); }; break; case 0b1000'000: { uint32_t imm32 = (instr >> 21) & 0x3E; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = get_reg(Rt); std::cout << "STRH R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_halfword(addr, data); }; break; case 0b1000'001: { uint32_t imm32 = (instr >> 21) & 0x3E; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = get_reg(Rt); std::cout << "STRH R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_halfword(addr, data); }; break; case 0b1000'010: { uint32_t imm32 = (instr >> 21) & 0x3E; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = get_reg(Rt); std::cout << "STRH R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_halfword(addr, data); }; break; case 0b1000'011: { uint32_t imm32 = (instr >> 21) & 0x3E; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = get_reg(Rt); std::cout << "STRH R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_halfword(addr, data); }; break; case 0b1000'100: { uint32_t imm32 = (instr >> 21) & 0x3E; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = co_await m_mpu_bus_interface.read_halfword(addr); std::cout << "LDRH R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; set_reg(Rt, data); }; break; case 0b1000'101: { uint32_t imm32 = (instr >> 21) & 0x3E; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = co_await m_mpu_bus_interface.read_halfword(addr); std::cout << "LDRH R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; set_reg(Rt, data); }; break; case 0b1000'110: { uint32_t imm32 = (instr >> 21) & 0x3E; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = co_await m_mpu_bus_interface.read_halfword(addr); std::cout << "LDRH R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; set_reg(Rt, data); }; break; case 0b1000'111: { uint32_t imm32 = (instr >> 21) & 0x3E; uint32_t Rt = (instr >> 16) & 0x7; uint32_t Rn = (instr >> 19) & 0x7; uint32_t addr = get_reg(Rn) + imm32; uint32_t data = co_await m_mpu_bus_interface.read_halfword(addr); std::cout << "LDRH R" << Rt << ", [R" << Rn << ", #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; set_reg(Rt, data); }; break; case 0b1001'000: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rt = (instr >> 24) & 0x7; uint32_t Rn = 13; uint32_t addr = get_reg(Rn) + imm32; std::cout << "STR R" << Rt << ", [SP, #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_word(addr, get_reg(Rt)); }; break; case 0b1001'001: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rt = (instr >> 24) & 0x7; uint32_t Rn = 13; uint32_t addr = get_reg(Rn) + imm32; std::cout << "STR R" << Rt << ", [SP, #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_word(addr, get_reg(Rt)); }; break; case 0b1001'010: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rt = (instr >> 24) & 0x7; uint32_t Rn = 13; uint32_t addr = get_reg(Rn) + imm32; std::cout << "STR R" << Rt << ", [SP, #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_word(addr, get_reg(Rt)); }; break; case 0b1001'011: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rt = (instr >> 24) & 0x7; uint32_t Rn = 13; uint32_t addr = get_reg(Rn) + imm32; std::cout << "STR R" << Rt << ", [SP, #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; co_await m_mpu_bus_interface.write_word(addr, get_reg(Rt)); }; break; case 0b1001'100: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rt = (instr >> 24) & 0x7; uint32_t Rn = 13; uint32_t addr = get_reg(Rn) + imm32; std::cout << "LDR R" << Rt << ", [SP, #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b1001'101: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rt = (instr >> 24) & 0x7; uint32_t Rn = 13; uint32_t addr = get_reg(Rn) + imm32; std::cout << "LDR R" << Rt << ", [SP, #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b1001'110: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rt = (instr >> 24) & 0x7; uint32_t Rn = 13; uint32_t addr = get_reg(Rn) + imm32; std::cout << "LDR R" << Rt << ", [SP, #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b1001'111: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rt = (instr >> 24) & 0x7; uint32_t Rn = 13; uint32_t addr = get_reg(Rn) + imm32; std::cout << "LDR R" << Rt << ", [SP, #" << imm32 << "] (" << std::hex << addr << std::dec << ")" << std::endl; uint32_t data = co_await m_mpu_bus_interface.read_word(addr); set_reg(Rt, data); }; break; case 0b1010'000: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rd = (instr >> 24) & 0x07; uint32_t addr = (PC() & ~0x03) + imm32 + 4; std::cout << "ADD R" << Rd << ", PC, #" << imm32 << "( " << std::hex << addr << std::dec << " )" << std::endl; set_reg(Rd, addr); }; break; case 0b1010'001: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rd = (instr >> 24) & 0x07; uint32_t addr = (PC() & ~0x03) + imm32 + 4; std::cout << "ADD R" << Rd << ", PC, #" << imm32 << "( " << std::hex << addr << std::dec << " )" << std::endl; set_reg(Rd, addr); }; break; case 0b1010'010: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rd = (instr >> 24) & 0x07; uint32_t addr = (PC() & ~0x03) + imm32 + 4; std::cout << "ADD R" << Rd << ", PC, #" << imm32 << "( " << std::hex << addr << std::dec << " )" << std::endl; set_reg(Rd, addr); }; break; case 0b1010'011: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rd = (instr >> 24) & 0x07; uint32_t addr = (PC() & ~0x03) + imm32 + 4; std::cout << "ADD R" << Rd << ", PC, #" << imm32 << "( " << std::hex << addr << std::dec << " )" << std::endl; set_reg(Rd, addr); }; break; case 0b1010'100: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rd = (instr >> 24) & 0x7; auto [result, carry, overflow] = AddWithCarry(SP(), imm32, 0); std::cout << "ADD R" << Rd << ", SP, #" << imm32 << "( " << std::hex << result << std::dec << " )" << std::endl; set_reg(Rd, result); }; break; case 0b1010'101: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rd = (instr >> 24) & 0x7; auto [result, carry, overflow] = AddWithCarry(SP(), imm32, 0); std::cout << "ADD R" << Rd << ", SP, #" << imm32 << "( " << std::hex << result << std::dec << " )" << std::endl; set_reg(Rd, result); }; break; case 0b1010'110: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rd = (instr >> 24) & 0x7; auto [result, carry, overflow] = AddWithCarry(SP(), imm32, 0); std::cout << "ADD R" << Rd << ", SP, #" << imm32 << "( " << std::hex << result << std::dec << " )" << std::endl; set_reg(Rd, result); }; break; case 0b1010'111: { uint32_t imm32 = (instr >> 14) & 0x3FC; uint32_t Rd = (instr >> 24) & 0x7; auto [result, carry, overflow] = AddWithCarry(SP(), imm32, 0); std::cout << "ADD R" << Rd << ", SP, #" << imm32 << "( " << std::hex << result << std::dec << " )" << std::endl; set_reg(Rd, result); }; break; case 0b1011'000: { switch(instr & 0x0080'0000){ case 0x0000'0000: { uint32_t imm32 = (instr >> 14) & 0x1fc; auto [newsp, carry, overflow] = AddWithCarry(SP(), imm32, 0); std::cout << "ADD SP, #" << imm32 << std::endl; SP() = newsp; } break; case 0x0080'0000: { uint32_t imm32 = (instr >> 14) & 0x1fc; auto [newsp, carry, overflow] = AddWithCarry(SP(), ~imm32, 1); std::cout << "SUB SP, #" << imm32 << std::endl; SP() = newsp; } break; default: throw HardFault{"SPSE something or other"}; } }; break; case 0b1011'001: { uint32_t Rd = (instr >> 16) & 0xf; uint32_t Rm = (instr >> 19) & 0xf; uint32_t Rm_val = get_reg(Rm); switch(instr & 0x00c0'0000){ case 0x0000'0000: { std::cout << "SXTH R" << Rd << ", R" << Rm << std::endl; Rm_val = Rm_val&0xffff; Rm_val |= 0 - (Rm_val&0x8000); set_reg(Rd, Rm_val); } break; case 0x0040'0000: { std::cout << "SXTB R" << Rd << ", R" << Rm << std::endl; Rm_val = Rm_val&0xff; Rm_val |= 0 - (Rm_val&0x80); set_reg(Rd, Rm_val); } break; case 0x0080'0000: { std::cout << "UXTH R" << Rd << ", R" << Rm << std::endl; Rm_val = Rm_val&0xffff; set_reg(Rd, Rm_val); } break; case 0x00c0'0000: { std::cout << "UXTB R" << Rd << ", R" << Rm << std::endl; Rm_val = Rm_val&0xff; set_reg(Rd, Rm_val); } break; default: throw HardFault{"Sign Extenison something or other"}; } }; break; case 0b1011'010: { uint32_t regs_list = (instr >> 16) & 0xff | (instr >> 10) & 0x4000; uint32_t addr = SP(); std::cout << "PUSH {" << std::bitset<16>{regs_list} << "}" << std::endl; for (int i = 14; i >= 0; i--) { if ((regs_list & (1<<i)) == 0) continue; co_await m_mpu_bus_interface.write_word(addr-4, get_reg(i)); addr -= 4; } SP() = addr; }; break; case 0b1011'011: { uint32_t im = instr & 0x0010'0000; std::cout << (im?"CPSIE i":"CPSID i") << std::endl; std::cout << "WARNING CPS INSTRUCTION NOT IMPLEMENTED" << std::endl; }; break; case 0b1011'100: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b1011'101: { uint32_t Rd = (instr >> 16) & 0x7; uint32_t Rm = (instr >> 19) & 0x7; uint32_t Rm_val = get_reg(Rm); switch(instr & 0x01c0'0000){ case 0x0000'0000: Rm_val = ((Rm_val & 0xff) << 24) | ((Rm_val & 0xff00) << 8) | ((Rm_val & 0xff0000) >> 8) | ((Rm_val & 0xff000000) >> 24); std::cout << "REV "; break; case 0x0040'0000: Rm_val = ((Rm_val & 0xffff) << 16) | ((Rm_val & 0xffff0000) >> 8); std::cout << "REV16 "; break; case 0x00c0'0000: Rm_val = ((Rm_val & 0xffff) << 16) | ((Rm_val & 0xffff0000) >> 8); std::cout << "REVSH "; default: throw HardFault{"bad REV instr"}; } std::cout << "R" << Rd << ", R" << Rm << std::endl; set_reg(Rd, Rm_val); }; break; case 0b1011'110: { uint32_t regs_list = (instr >> 16) & 0xff | (instr >> 9) & 0x8000; uint32_t addr = SP(); std::cout << "POP {" << std::bitset<16>{regs_list} << "}" << std::endl; for (int i = 0; i <= 7; i++) { if ((regs_list & (1<<i)) == 0) continue; std::cout << "popping from " << std::hex << addr << std::dec << std::endl; set_reg(i, co_await m_mpu_bus_interface.read_word(addr)); addr += 4; } if (regs_list & (1<<15)) { std::cout << "popping from " << std::hex << addr << std::dec << std::endl; m_nextPC = co_await m_mpu_bus_interface.read_word(addr); std::cout << "new PC " << std::hex << m_nextPC << std::dec << std::endl; addr += 4; } std::cout << "POP {" << std::bitset<16>{regs_list} << "}" << std::endl; SP() = addr; }; break; case 0b1011'111: { if (instr & (1<<24)){ uint32_t opa = (instr >> 20) & 0xf; switch(opa) { case 0b0000: std::cout << "NOP" << std::endl; break; case 0b0001: std::cout << "YIELD" << std::endl; break; case 0b0010: std::cout << "WFE" << std::endl; break; case 0b0011: std::cout << "WFI" << std::endl; break; case 0b0100: std::cout << "SEV" << std::endl; break; default: throw HardFault{"Undefined opcode"}; } } else { uint32_t imm8 = (instr >> 16) & 0xFF; std::cout << "BKPT #" << imm8 << std::endl; } }; break; case 0b1100'000: { uint32_t Rn = (instr >> 24) & 0x7; uint32_t reg_list = (instr >> 16) & 0xff; bool wback = true; uint32_t Rn_val = get_reg(Rn); std::cout << "STMIA R" << Rn << (wback?"! {":" {") << std::bitset<8>{reg_list} << "}" << std::endl; for (int i = 0; i < 8; i++) { if ((reg_list & (1<<i)) == 0) continue; co_await m_mpu_bus_interface.write_word(Rn_val, get_reg(i)); Rn_val += 4; } if (wback) set_reg(Rn, Rn_val); }; break; case 0b1100'001: { uint32_t Rn = (instr >> 24) & 0x7; uint32_t reg_list = (instr >> 16) & 0xff; bool wback = true; uint32_t Rn_val = get_reg(Rn); std::cout << "STMIA R" << Rn << (wback?"! {":" {") << std::bitset<8>{reg_list} << "}" << std::endl; for (int i = 0; i < 8; i++) { if ((reg_list & (1<<i)) == 0) continue; co_await m_mpu_bus_interface.write_word(Rn_val, get_reg(i)); Rn_val += 4; } if (wback) set_reg(Rn, Rn_val); }; break; case 0b1100'010: { uint32_t Rn = (instr >> 24) & 0x7; uint32_t reg_list = (instr >> 16) & 0xff; bool wback = true; uint32_t Rn_val = get_reg(Rn); std::cout << "STMIA R" << Rn << (wback?"! {":" {") << std::bitset<8>{reg_list} << "}" << std::endl; for (int i = 0; i < 8; i++) { if ((reg_list & (1<<i)) == 0) continue; co_await m_mpu_bus_interface.write_word(Rn_val, get_reg(i)); Rn_val += 4; } if (wback) set_reg(Rn, Rn_val); }; break; case 0b1100'011: { uint32_t Rn = (instr >> 24) & 0x7; uint32_t reg_list = (instr >> 16) & 0xff; bool wback = true; uint32_t Rn_val = get_reg(Rn); std::cout << "STMIA R" << Rn << (wback?"! {":" {") << std::bitset<8>{reg_list} << "}" << std::endl; for (int i = 0; i < 8; i++) { if ((reg_list & (1<<i)) == 0) continue; co_await m_mpu_bus_interface.write_word(Rn_val, get_reg(i)); Rn_val += 4; } if (wback) set_reg(Rn, Rn_val); }; break; case 0b1100'100: { uint32_t Rn = (instr >> 24) & 0x7; uint32_t reg_list = (instr >> 16) & 0xff; bool wback = (reg_list & (1<<Rn)) == 0; uint32_t Rn_val = get_reg(Rn); std::cout << "LDMIA R" << Rn << (wback?"! {":" {") << std::bitset<8>{reg_list} << "}" << std::endl; for (int i = 0; i < 8; i++) { if ((reg_list & (1<<i)) == 0) continue; set_reg(i, co_await m_mpu_bus_interface.read_word(Rn_val)); Rn_val += 4; } if (wback) set_reg(Rn, Rn_val); }; break; case 0b1100'101: { uint32_t Rn = (instr >> 24) & 0x7; uint32_t reg_list = (instr >> 16) & 0xff; bool wback = (reg_list & (1<<Rn)) == 0; uint32_t Rn_val = get_reg(Rn); std::cout << "LDMIA R" << Rn << (wback?"! {":" {") << std::bitset<8>{reg_list} << "}" << std::endl; for (int i = 0; i < 8; i++) { if ((reg_list & (1<<i)) == 0) continue; set_reg(i, co_await m_mpu_bus_interface.read_word(Rn_val)); Rn_val += 4; } if (wback) set_reg(Rn, Rn_val); }; break; case 0b1100'110: { uint32_t Rn = (instr >> 24) & 0x7; uint32_t reg_list = (instr >> 16) & 0xff; bool wback = (reg_list & (1<<Rn)) == 0; uint32_t Rn_val = get_reg(Rn); std::cout << "LDMIA R" << Rn << (wback?"! {":" {") << std::bitset<8>{reg_list} << "}" << std::endl; for (int i = 0; i < 8; i++) { if ((reg_list & (1<<i)) == 0) continue; set_reg(i, co_await m_mpu_bus_interface.read_word(Rn_val)); Rn_val += 4; } if (wback) set_reg(Rn, Rn_val); }; break; case 0b1100'111: { uint32_t Rn = (instr >> 24) & 0x7; uint32_t reg_list = (instr >> 16) & 0xff; bool wback = (reg_list & (1<<Rn)) == 0; uint32_t Rn_val = get_reg(Rn); std::cout << "LDMIA R" << Rn << (wback?"! {":" {") << std::bitset<8>{reg_list} << "}" << std::endl; for (int i = 0; i < 8; i++) { if ((reg_list & (1<<i)) == 0) continue; set_reg(i, co_await m_mpu_bus_interface.read_word(Rn_val)); Rn_val += 4; } if (wback) set_reg(Rn, Rn_val); }; break; case 0b1101'000: { uint32_t cond = (instr >> 24) & 0xf; uint32_t imm8 = (instr >> 16) & 0xFF; if (imm8 >= 128) imm8 -= 256; uint32_t addr = PC() + imm8*2 + 4; bool jump; switch (cond) { case Cond::EQ: jump = (m_APSR & APSR::ZERO); std::cout << "BEQ "; break; case Cond::NE: jump = !(m_APSR & APSR::ZERO); std::cout << "BNE "; break; case Cond::CS: jump = (m_APSR & APSR::CARRY); std::cout << "BCS "; break; case Cond::CC: jump = !(m_APSR & APSR::CARRY); std::cout << "BCC "; break; case Cond::MI: jump = (m_APSR & APSR::NEGATIVE); std::cout << "BMI "; break; case Cond::PL: jump = !(m_APSR & APSR::NEGATIVE); std::cout << "BPL "; break; case Cond::VS: jump = (m_APSR & APSR::OVERFLOW); std::cout << "BVS "; break; case Cond::VC: jump = !(m_APSR & APSR::OVERFLOW); std::cout << "BVC "; break; case Cond::HI: jump = ((m_APSR & APSR::CARRY) && !(m_APSR & APSR::ZERO)); std::cout << "BHI "; break; case Cond::LS: jump = (!(m_APSR & APSR::CARRY) || (m_APSR & APSR::ZERO)); std::cout << "BLS "; break; case Cond::GE: jump = (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW)); std::cout << "BGE "; break; case Cond::LT: jump = (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW)); std::cout << "BLT "; break; case Cond::GT: jump = (!(m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW))); std::cout << "BGT "; break; case Cond::LE: jump = ((m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW))); std::cout << "BLE "; break; default: throw HardFault{"unrecognised branch instr"}; } std::cout << std::hex << addr << std::dec << " " << std::bitset<4>{m_APSR>>28} << (jump?" y":" n") << std::endl; if (jump) { m_nextPC = addr; } }; break; case 0b1101'001: { uint32_t cond = (instr >> 24) & 0xf; uint32_t imm8 = (instr >> 16) & 0xFF; if (imm8 >= 128) imm8 -= 256; uint32_t addr = PC() + imm8*2 + 4; bool jump; switch (cond) { case Cond::EQ: jump = (m_APSR & APSR::ZERO); std::cout << "BEQ "; break; case Cond::NE: jump = !(m_APSR & APSR::ZERO); std::cout << "BNE "; break; case Cond::CS: jump = (m_APSR & APSR::CARRY); std::cout << "BCS "; break; case Cond::CC: jump = !(m_APSR & APSR::CARRY); std::cout << "BCC "; break; case Cond::MI: jump = (m_APSR & APSR::NEGATIVE); std::cout << "BMI "; break; case Cond::PL: jump = !(m_APSR & APSR::NEGATIVE); std::cout << "BPL "; break; case Cond::VS: jump = (m_APSR & APSR::OVERFLOW); std::cout << "BVS "; break; case Cond::VC: jump = !(m_APSR & APSR::OVERFLOW); std::cout << "BVC "; break; case Cond::HI: jump = ((m_APSR & APSR::CARRY) && !(m_APSR & APSR::ZERO)); std::cout << "BHI "; break; case Cond::LS: jump = (!(m_APSR & APSR::CARRY) || (m_APSR & APSR::ZERO)); std::cout << "BLS "; break; case Cond::GE: jump = (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW)); std::cout << "BGE "; break; case Cond::LT: jump = (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW)); std::cout << "BLT "; break; case Cond::GT: jump = (!(m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW))); std::cout << "BGT "; break; case Cond::LE: jump = ((m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW))); std::cout << "BLE "; break; default: throw HardFault{"unrecognised branch instr"}; } std::cout << std::hex << addr << std::dec << " " << std::bitset<4>{m_APSR>>28} << (jump?" y":" n") << std::endl; if (jump) { m_nextPC = addr; } }; break; case 0b1101'010: { uint32_t cond = (instr >> 24) & 0xf; uint32_t imm8 = (instr >> 16) & 0xFF; if (imm8 >= 128) imm8 -= 256; uint32_t addr = PC() + imm8*2 + 4; bool jump; switch (cond) { case Cond::EQ: jump = (m_APSR & APSR::ZERO); std::cout << "BEQ "; break; case Cond::NE: jump = !(m_APSR & APSR::ZERO); std::cout << "BNE "; break; case Cond::CS: jump = (m_APSR & APSR::CARRY); std::cout << "BCS "; break; case Cond::CC: jump = !(m_APSR & APSR::CARRY); std::cout << "BCC "; break; case Cond::MI: jump = (m_APSR & APSR::NEGATIVE); std::cout << "BMI "; break; case Cond::PL: jump = !(m_APSR & APSR::NEGATIVE); std::cout << "BPL "; break; case Cond::VS: jump = (m_APSR & APSR::OVERFLOW); std::cout << "BVS "; break; case Cond::VC: jump = !(m_APSR & APSR::OVERFLOW); std::cout << "BVC "; break; case Cond::HI: jump = ((m_APSR & APSR::CARRY) && !(m_APSR & APSR::ZERO)); std::cout << "BHI "; break; case Cond::LS: jump = (!(m_APSR & APSR::CARRY) || (m_APSR & APSR::ZERO)); std::cout << "BLS "; break; case Cond::GE: jump = (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW)); std::cout << "BGE "; break; case Cond::LT: jump = (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW)); std::cout << "BLT "; break; case Cond::GT: jump = (!(m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW))); std::cout << "BGT "; break; case Cond::LE: jump = ((m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW))); std::cout << "BLE "; break; default: throw HardFault{"unrecognised branch instr"}; } std::cout << std::hex << addr << std::dec << " " << std::bitset<4>{m_APSR>>28} << (jump?" y":" n") << std::endl; if (jump) { m_nextPC = addr; } }; break; case 0b1101'011: { uint32_t cond = (instr >> 24) & 0xf; uint32_t imm8 = (instr >> 16) & 0xFF; if (imm8 >= 128) imm8 -= 256; uint32_t addr = PC() + imm8*2 + 4; bool jump; switch (cond) { case Cond::EQ: jump = (m_APSR & APSR::ZERO); std::cout << "BEQ "; break; case Cond::NE: jump = !(m_APSR & APSR::ZERO); std::cout << "BNE "; break; case Cond::CS: jump = (m_APSR & APSR::CARRY); std::cout << "BCS "; break; case Cond::CC: jump = !(m_APSR & APSR::CARRY); std::cout << "BCC "; break; case Cond::MI: jump = (m_APSR & APSR::NEGATIVE); std::cout << "BMI "; break; case Cond::PL: jump = !(m_APSR & APSR::NEGATIVE); std::cout << "BPL "; break; case Cond::VS: jump = (m_APSR & APSR::OVERFLOW); std::cout << "BVS "; break; case Cond::VC: jump = !(m_APSR & APSR::OVERFLOW); std::cout << "BVC "; break; case Cond::HI: jump = ((m_APSR & APSR::CARRY) && !(m_APSR & APSR::ZERO)); std::cout << "BHI "; break; case Cond::LS: jump = (!(m_APSR & APSR::CARRY) || (m_APSR & APSR::ZERO)); std::cout << "BLS "; break; case Cond::GE: jump = (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW)); std::cout << "BGE "; break; case Cond::LT: jump = (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW)); std::cout << "BLT "; break; case Cond::GT: jump = (!(m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW))); std::cout << "BGT "; break; case Cond::LE: jump = ((m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW))); std::cout << "BLE "; break; default: throw HardFault{"unrecognised branch instr"}; } std::cout << std::hex << addr << std::dec << " " << std::bitset<4>{m_APSR>>28} << (jump?" y":" n") << std::endl; if (jump) { m_nextPC = addr; } }; break; case 0b1101'100: { uint32_t cond = (instr >> 24) & 0xf; uint32_t imm8 = (instr >> 16) & 0xFF; if (imm8 >= 128) imm8 -= 256; uint32_t addr = PC() + imm8*2 + 4; bool jump; switch (cond) { case Cond::EQ: jump = (m_APSR & APSR::ZERO); std::cout << "BEQ "; break; case Cond::NE: jump = !(m_APSR & APSR::ZERO); std::cout << "BNE "; break; case Cond::CS: jump = (m_APSR & APSR::CARRY); std::cout << "BCS "; break; case Cond::CC: jump = !(m_APSR & APSR::CARRY); std::cout << "BCC "; break; case Cond::MI: jump = (m_APSR & APSR::NEGATIVE); std::cout << "BMI "; break; case Cond::PL: jump = !(m_APSR & APSR::NEGATIVE); std::cout << "BPL "; break; case Cond::VS: jump = (m_APSR & APSR::OVERFLOW); std::cout << "BVS "; break; case Cond::VC: jump = !(m_APSR & APSR::OVERFLOW); std::cout << "BVC "; break; case Cond::HI: jump = ((m_APSR & APSR::CARRY) && !(m_APSR & APSR::ZERO)); std::cout << "BHI "; break; case Cond::LS: jump = (!(m_APSR & APSR::CARRY) || (m_APSR & APSR::ZERO)); std::cout << "BLS "; break; case Cond::GE: jump = (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW)); std::cout << "BGE "; break; case Cond::LT: jump = (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW)); std::cout << "BLT "; break; case Cond::GT: jump = (!(m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW))); std::cout << "BGT "; break; case Cond::LE: jump = ((m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW))); std::cout << "BLE "; break; default: throw HardFault{"unrecognised branch instr"}; } std::cout << std::hex << addr << std::dec << " " << std::bitset<4>{m_APSR>>28} << (jump?" y":" n") << std::endl; if (jump) { m_nextPC = addr; } }; break; case 0b1101'101: { uint32_t cond = (instr >> 24) & 0xf; uint32_t imm8 = (instr >> 16) & 0xFF; if (imm8 >= 128) imm8 -= 256; uint32_t addr = PC() + imm8*2 + 4; bool jump; switch (cond) { case Cond::EQ: jump = (m_APSR & APSR::ZERO); std::cout << "BEQ "; break; case Cond::NE: jump = !(m_APSR & APSR::ZERO); std::cout << "BNE "; break; case Cond::CS: jump = (m_APSR & APSR::CARRY); std::cout << "BCS "; break; case Cond::CC: jump = !(m_APSR & APSR::CARRY); std::cout << "BCC "; break; case Cond::MI: jump = (m_APSR & APSR::NEGATIVE); std::cout << "BMI "; break; case Cond::PL: jump = !(m_APSR & APSR::NEGATIVE); std::cout << "BPL "; break; case Cond::VS: jump = (m_APSR & APSR::OVERFLOW); std::cout << "BVS "; break; case Cond::VC: jump = !(m_APSR & APSR::OVERFLOW); std::cout << "BVC "; break; case Cond::HI: jump = ((m_APSR & APSR::CARRY) && !(m_APSR & APSR::ZERO)); std::cout << "BHI "; break; case Cond::LS: jump = (!(m_APSR & APSR::CARRY) || (m_APSR & APSR::ZERO)); std::cout << "BLS "; break; case Cond::GE: jump = (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW)); std::cout << "BGE "; break; case Cond::LT: jump = (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW)); std::cout << "BLT "; break; case Cond::GT: jump = (!(m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW))); std::cout << "BGT "; break; case Cond::LE: jump = ((m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW))); std::cout << "BLE "; break; default: throw HardFault{"unrecognised branch instr"}; } std::cout << std::hex << addr << std::dec << " " << std::bitset<4>{m_APSR>>28} << (jump?" y":" n") << std::endl; if (jump) { m_nextPC = addr; } }; break; case 0b1101'110: { uint32_t cond = (instr >> 24) & 0xf; uint32_t imm8 = (instr >> 16) & 0xFF; if (imm8 >= 128) imm8 -= 256; uint32_t addr = PC() + imm8*2 + 4; bool jump; switch (cond) { case Cond::EQ: jump = (m_APSR & APSR::ZERO); std::cout << "BEQ "; break; case Cond::NE: jump = !(m_APSR & APSR::ZERO); std::cout << "BNE "; break; case Cond::CS: jump = (m_APSR & APSR::CARRY); std::cout << "BCS "; break; case Cond::CC: jump = !(m_APSR & APSR::CARRY); std::cout << "BCC "; break; case Cond::MI: jump = (m_APSR & APSR::NEGATIVE); std::cout << "BMI "; break; case Cond::PL: jump = !(m_APSR & APSR::NEGATIVE); std::cout << "BPL "; break; case Cond::VS: jump = (m_APSR & APSR::OVERFLOW); std::cout << "BVS "; break; case Cond::VC: jump = !(m_APSR & APSR::OVERFLOW); std::cout << "BVC "; break; case Cond::HI: jump = ((m_APSR & APSR::CARRY) && !(m_APSR & APSR::ZERO)); std::cout << "BHI "; break; case Cond::LS: jump = (!(m_APSR & APSR::CARRY) || (m_APSR & APSR::ZERO)); std::cout << "BLS "; break; case Cond::GE: jump = (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW)); std::cout << "BGE "; break; case Cond::LT: jump = (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW)); std::cout << "BLT "; break; case Cond::GT: jump = (!(m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW))); std::cout << "BGT "; break; case Cond::LE: jump = ((m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW))); std::cout << "BLE "; break; default: throw HardFault{"unrecognised branch instr"}; } std::cout << std::hex << addr << std::dec << " " << std::bitset<4>{m_APSR>>28} << (jump?" y":" n") << std::endl; if (jump) { m_nextPC = addr; } }; break; case 0b1101'111: { uint32_t cond = (instr >> 24) & 0xf; uint32_t imm8 = (instr >> 16) & 0xFF; if (imm8 >= 128) imm8 -= 256; uint32_t addr = PC() + imm8*2 + 4; bool jump; switch (cond) { case Cond::EQ: jump = (m_APSR & APSR::ZERO); std::cout << "BEQ "; break; case Cond::NE: jump = !(m_APSR & APSR::ZERO); std::cout << "BNE "; break; case Cond::CS: jump = (m_APSR & APSR::CARRY); std::cout << "BCS "; break; case Cond::CC: jump = !(m_APSR & APSR::CARRY); std::cout << "BCC "; break; case Cond::MI: jump = (m_APSR & APSR::NEGATIVE); std::cout << "BMI "; break; case Cond::PL: jump = !(m_APSR & APSR::NEGATIVE); std::cout << "BPL "; break; case Cond::VS: jump = (m_APSR & APSR::OVERFLOW); std::cout << "BVS "; break; case Cond::VC: jump = !(m_APSR & APSR::OVERFLOW); std::cout << "BVC "; break; case Cond::HI: jump = ((m_APSR & APSR::CARRY) && !(m_APSR & APSR::ZERO)); std::cout << "BHI "; break; case Cond::LS: jump = (!(m_APSR & APSR::CARRY) || (m_APSR & APSR::ZERO)); std::cout << "BLS "; break; case Cond::GE: jump = (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW)); std::cout << "BGE "; break; case Cond::LT: jump = (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW)); std::cout << "BLT "; break; case Cond::GT: jump = (!(m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) == !!(m_APSR & APSR::OVERFLOW))); std::cout << "BGT "; break; case Cond::LE: jump = ((m_APSR & APSR::ZERO) && (!!(m_APSR & APSR::NEGATIVE) != !!(m_APSR & APSR::OVERFLOW))); std::cout << "BLE "; break; default: throw HardFault{"unrecognised branch instr"}; } std::cout << std::hex << addr << std::dec << " " << std::bitset<4>{m_APSR>>28} << (jump?" y":" n") << std::endl; if (jump) { m_nextPC = addr; } }; break; case 0b1110'000: { uint32_t imm11 = (instr >> 15) & 0xffe; if (imm11 >= 2048) imm11 -= 4096; uint32_t addr = PC() + imm11 + 4; std::cout << "B " << std::hex << addr << std::dec << std::endl; m_nextPC = addr; }; break; case 0b1110'001: { uint32_t imm11 = (instr >> 15) & 0xffe; if (imm11 >= 2048) imm11 -= 4096; uint32_t addr = PC() + imm11 + 4; std::cout << "B " << std::hex << addr << std::dec << std::endl; m_nextPC = addr; }; break; case 0b1110'010: { uint32_t imm11 = (instr >> 15) & 0xffe; if (imm11 >= 2048) imm11 -= 4096; uint32_t addr = PC() + imm11 + 4; std::cout << "B " << std::hex << addr << std::dec << std::endl; m_nextPC = addr; }; break; case 0b1110'011: { uint32_t imm11 = (instr >> 15) & 0xffe; if (imm11 >= 2048) imm11 -= 4096; uint32_t addr = PC() + imm11 + 4; std::cout << "B " << std::hex << addr << std::dec << std::endl; m_nextPC = addr; }; break; case 0b1110'100: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b1110'101: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b1110'110: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b1110'111: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b1111'000: { if ((instr & 0x0000'5000) == 0x0000'0000) { { uint32_t sysm = instr & 0xff; uint32_t Rd = (instr >> 8) & 0xf; uint32_t Rn = (instr >> 16) & 0xf; switch(instr & 0x07e0'0000){ case 0x0380'0000: { switch(sysm){ case 0x04: case 0x05: case 0x06: m_APSR = get_reg(Rn) & 0xf800'0000; break; case 0x08: if (CurrentModeIsPrivileged()) { set_MSP(get_reg(Rn) & ~0x3); } break; case 0x09: if (CurrentModeIsPrivileged()) { set_PSP(get_reg(Rn) & ~0x3); } break; } } case 0x03e0'0000: ; } } } else { uint8_t cond = (instr >> 24) & 0xf; uint32_t imm11 = (instr) & 0x7ff; uint32_t imm10 = (instr >> 16) & 0x3ff; uint32_t I1 = 1^((instr >> 13) &1); uint32_t I2 = 1^((instr >> 11) &1); uint32_t imm32 = ((imm11 << 1) | (imm10 << 12) | (I2 << 22) | (I1 << 23)); uint32_t addr = m_nextPC + imm32; std::cout << "BL " << std::hex << addr << std::dec << std::endl; LR() = m_nextPC; m_nextPC = addr; } }; break; case 0b1111'001: { if ((instr & 0x0000'5000) == 0x0000'0000) { { uint32_t sysm = instr & 0xff; uint32_t Rd = (instr >> 8) & 0xf; uint32_t Rn = (instr >> 16) & 0xf; switch(instr & 0x07e0'0000){ case 0x0380'0000: { switch(sysm){ case 0x04: case 0x05: case 0x06: m_APSR = get_reg(Rn) & 0xf800'0000; break; case 0x08: if (CurrentModeIsPrivileged()) { set_MSP(get_reg(Rn) & ~0x3); } break; case 0x09: if (CurrentModeIsPrivileged()) { set_PSP(get_reg(Rn) & ~0x3); } break; } } case 0x03e0'0000: ; } } } else { uint8_t cond = (instr >> 24) & 0xf; uint32_t imm11 = (instr) & 0x7ff; uint32_t imm10 = (instr >> 16) & 0x3ff; uint32_t I1 = 1^((instr >> 13) &1); uint32_t I2 = 1^((instr >> 11) &1); uint32_t imm32 = ((imm11 << 1) | (imm10 << 12) | (I2 << 22) | (I1 << 23)); uint32_t addr = m_nextPC + imm32; std::cout << "BL " << std::hex << addr << std::dec << std::endl; LR() = m_nextPC; m_nextPC = addr; } }; break; case 0b1111'010: { if ((instr & 0x0000'5000) == 0x0000'0000) { { uint32_t sysm = instr & 0xff; uint32_t Rd = (instr >> 8) & 0xf; uint32_t Rn = (instr >> 16) & 0xf; switch(instr & 0x07e0'0000){ case 0x0380'0000: { switch(sysm){ case 0x04: case 0x05: case 0x06: m_APSR = get_reg(Rn) & 0xf800'0000; break; case 0x08: if (CurrentModeIsPrivileged()) { set_MSP(get_reg(Rn) & ~0x3); } break; case 0x09: if (CurrentModeIsPrivileged()) { set_PSP(get_reg(Rn) & ~0x3); } break; } } case 0x03e0'0000: ; } } } else { uint8_t cond = (instr >> 24) & 0xf; uint32_t imm11 = (instr) & 0x7ff; uint32_t imm10 = (instr >> 16) & 0x3ff; uint32_t I1 = (instr >> 13) &1; uint32_t I2 = (instr >> 11) &1; uint32_t imm32 = ((imm11 << 1) | (imm10 << 12) | (I2 << 22) | (I1 << 23)) - (1<<24); uint32_t addr = m_nextPC + imm32; std::cout << "BL " << std::hex << addr << std::dec << std::endl; LR() = m_nextPC; m_nextPC = addr; } }; break; case 0b1111'011: { if ((instr & 0x0000'5000) == 0x0000'0000) { { uint32_t sysm = instr & 0xff; uint32_t Rd = (instr >> 8) & 0xf; uint32_t Rn = (instr >> 16) & 0xf; switch(instr & 0x07e0'0000){ case 0x0380'0000: { switch(sysm){ case 0x04: case 0x05: case 0x06: m_APSR = get_reg(Rn) & 0xf800'0000; break; case 0x08: if (CurrentModeIsPrivileged()) { set_MSP(get_reg(Rn) & ~0x3); } break; case 0x09: if (CurrentModeIsPrivileged()) { set_PSP(get_reg(Rn) & ~0x3); } break; } } case 0x03e0'0000: ; } } } else { uint8_t cond = (instr >> 24) & 0xf; uint32_t imm11 = (instr) & 0x7ff; uint32_t imm10 = (instr >> 16) & 0x3ff; uint32_t I1 = (instr >> 13) &1; uint32_t I2 = (instr >> 11) &1; uint32_t imm32 = ((imm11 << 1) | (imm10 << 12) | (I2 << 22) | (I1 << 23)) - (1<<24); uint32_t addr = m_nextPC + imm32; std::cout << "BL " << std::hex << addr << std::dec << std::endl; LR() = m_nextPC; m_nextPC = addr; } }; break; case 0b1111'100: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b1111'101: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b1111'110: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break; case 0b1111'111: { std::cout << "Undefined opcode " << std::hex << instr << std::endl; throw HardFault{"Undefined OpCode"}; }; break;
  }





  co_return;
}


PortState ARMv6MCore::PPB::read_byte(uint32_t addr, uint8_t &out){ throw ARMv6M::BusFault(); }
PortState ARMv6MCore::PPB::read_halfword(uint32_t addr, uint16_t &out){ throw ARMv6M::BusFault(); }
PortState ARMv6MCore::PPB::read_word(uint32_t addr, uint32_t &out){
  std::cout << "PPB::read_word(" << std::hex << addr << std::dec << ")" << std::endl;
  switch(addr) {
    case 0xE000ED00:
      out = 0x410CC601;
      break;
    case 0xE000ED04:
      out = 0;
      break;
    case 0xE000ED08:
      out = 0;
      break;
    case 0xE000ED0C:
      out = 0;
      break;
    case 0xE000ED10:
      out = 0;
      break;
    case 0xE000ED14:
      out = 0;
      break;
    case 0xE000ED18:
      out = 0;
      break;
    case 0xE000ED1C:
      out = 0;
      break;
    case 0xE000ED20:
      out = 0;
      break;
    case 0xE000ED24:
      out = 0;
      break;
    case 0xE000ED28:
      out = 0;
      break;
    case 0xE000ED2C:
      out = 0;
      break;
    case 0xE000ED30:
      out = 0;
      break;
    case 0xE000ED34:
      out = 0;
      break;
    case 0xE000ED38:
      out = 0;
      break;
    case 0xE000ED3C:
      out = 0;
      break;
    case 0xE000ED40:
      out = 0;
      break;
    case 0xE000ED44:
      out = 0;
      break;
    case 0xE000ED48:
      out = 0;
      break;
    case 0xE000ED4C:
      out = 0;
      break;
    case 0xE000ED50:
      out = 0;
      break;
    case 0xE000ED54:
      out = 0;
      break;
  }
  return PortState::SUCCESS;
}
PortState ARMv6MCore::PPB::write_byte(uint32_t addr, uint8_t in){ throw ARMv6M::BusFault(); }
PortState ARMv6MCore::PPB::write_halfword(uint32_t addr, uint16_t in){ throw ARMv6M::BusFault(); }
PortState ARMv6MCore::PPB::write_word(uint32_t addr, uint32_t in){
  switch(addr) {
    case 0xE000ED00:
      break;
    case 0xE000ED04:
      break;
    case 0xE000ED08:
      break;
    case 0xE000ED0C:
      break;
    case 0xE000ED10:
      break;
    case 0xE000ED14:
      break;
    case 0xE000ED18:
      break;
    case 0xE000ED1C:
      break;
    case 0xE000ED20:
      break;
    case 0xE000ED24:
      break;
    case 0xE000ED28:
      break;
    case 0xE000ED2C:
      break;
    case 0xE000ED30:
      break;
    case 0xE000ED34:
      break;
    case 0xE000ED38:
      break;
    case 0xE000ED3C:
      break;
    case 0xE000ED40:
      break;
    case 0xE000ED44:
      break;
    case 0xE000ED48:
      break;
    case 0xE000ED4C:
      break;
    case 0xE000ED50:
      break;
    case 0xE000ED54:
      break;
  }
  return PortState::SUCCESS;
}
